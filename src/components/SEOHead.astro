---
import type { ImageMetadata } from 'astro';
import type { CollectionEntry } from 'astro:content';
import {
	SITE_AUTHOR,
	SITE_DESCRIPTION,
	SITE_LOCALE,
	SITE_NAME,
	SITE_TITLE,
	SITE_TWITTER_HANDLE,
	SITE_URL,
} from '../consts';

interface Props {
	title: string;
	description: string;
	image?: ImageMetadata;
	imageAlt?: string;
	type?: 'website' | 'article';
	// Article-specific props
	article?: {
		publishedTime?: Date;
		modifiedTime?: Date;
		author?: {
			name: string;
			url?: string;
		};
		section?: string;
		tags?: string[];
	};
	// Schema.org props
	schema?: {
		type?: 'BlogPosting' | 'Article' | 'Person' | 'Organization' | 'WebSite' | 'Blog' | Array<'BlogPosting' | 'Article' | 'Person' | 'Organization' | 'WebSite' | 'Blog'>;
		post?: CollectionEntry<'blog'>;
		breadcrumbs?: Array<{ name: string; url: string }>;
	};
	// Additional meta
	robots?: string;
	keywords?: string[];
	canonical?: URL;
}

const {
	title,
	description,
	image,
	imageAlt = '',
	type = 'website',
	article,
	schema,
	robots = 'index, follow',
	keywords,
	canonical,
} = Astro.props;

const canonicalURL = canonical || new URL(Astro.url.pathname, Astro.site);
const pageURL = Astro.url;

// Get image URL and dimensions
let imageURL: URL | undefined;
let imageWidth: number | undefined;
let imageHeight: number | undefined;

if (image) {
	imageURL = new URL(image.src, Astro.url);
	// Try to get dimensions from image metadata
	if ('width' in image && typeof image.width === 'number') {
		imageWidth = image.width;
	}
	if ('height' in image && typeof image.height === 'number') {
		imageHeight = image.height;
	}
}

// Get author information
const author = article?.author || {
	name: SITE_AUTHOR.name,
	url: SITE_AUTHOR.social.website,
};

	// Build Schema.org JSON-LD
const buildSchema = () => {
	const schemas: Record<string, any>[] = [];
	const schemaTypes = Array.isArray(schema?.type) ? schema.type : schema?.type ? [schema.type] : [];

	// Handle multiple schema types (e.g., WebSite + Organization)
	if (schemaTypes.includes('WebSite')) {
		schemas.push({
			'@context': 'https://schema.org',
			'@type': 'WebSite',
			name: SITE_NAME,
			description: SITE_DESCRIPTION,
			url: SITE_URL,
			publisher: {
				'@type': 'Organization',
				name: SITE_NAME,
			},
		});
	}

	if (schemaTypes.includes('Organization')) {
		schemas.push({
			'@context': 'https://schema.org',
			'@type': 'Organization',
			name: SITE_NAME,
			description: SITE_DESCRIPTION,
			url: SITE_URL,
			logo: new URL('/favicon.svg', Astro.site).toString(),
		});
	}

	if (schema?.type === 'BlogPosting' && schema.post) {
		const post = schema.post;
		const postURL = new URL(`/blog/${post.id}/`, Astro.site);
		const heroImageURL = post.data.heroImage
			? new URL(post.data.heroImage.src, Astro.url)
			: imageURL;

		// BlogPosting schema
		const blogPosting: any = {
			'@context': 'https://schema.org',
			'@type': 'BlogPosting',
			headline: post.data.title,
			description: post.data.description,
			image: heroImageURL?.toString(),
			datePublished: post.data.pubDate.toISOString(),
			dateModified: (post.data.updatedDate || post.data.pubDate).toISOString(),
			author: {
				'@type': 'Person',
				name: post.data.author?.name || SITE_AUTHOR.name,
				...(post.data.author?.social?.website && {
					url: post.data.author.social.website,
				}),
				...(post.data.author?.social?.twitter && {
					sameAs: `https://twitter.com/${post.data.author.social.twitter.replace('@', '')}`,
				}),
			},
			publisher: {
				'@type': 'Organization',
				name: SITE_NAME,
				logo: {
					'@type': 'ImageObject',
					url: new URL('/favicon.svg', Astro.site).toString(),
				},
			},
			mainEntityOfPage: {
				'@type': 'WebPage',
				'@id': postURL.toString(),
			},
		};

		if (post.data.tags && post.data.tags.length > 0) {
			blogPosting.keywords = post.data.tags.join(', ');
		}

		schemas.push(blogPosting);

		// Article schema (additional)
		const articleSchema = {
			'@context': 'https://schema.org',
			'@type': 'Article',
			headline: post.data.title,
			description: post.data.description,
			image: heroImageURL?.toString(),
			datePublished: post.data.pubDate.toISOString(),
			dateModified: (post.data.updatedDate || post.data.pubDate).toISOString(),
			author: {
				'@type': 'Person',
				name: post.data.author?.name || SITE_AUTHOR.name,
			},
			publisher: {
				'@type': 'Organization',
				name: SITE_NAME,
			},
		};
		schemas.push(articleSchema);
	}

	if (schema?.type === 'Person' || schemaTypes.includes('Person')) {
		schemas.push({
			'@context': 'https://schema.org',
			'@type': 'Person',
			name: SITE_AUTHOR.name,
			description: SITE_AUTHOR.bio,
			url: SITE_AUTHOR.social.website,
			sameAs: [
				...(SITE_AUTHOR.social.github
					? [`https://github.com/${SITE_AUTHOR.social.github}`]
					: []),
				...(SITE_AUTHOR.social.twitter
					? [`https://twitter.com/${SITE_AUTHOR.social.twitter.replace('@', '')}`]
					: []),
				...(SITE_AUTHOR.social.linkedin ? [SITE_AUTHOR.social.linkedin] : []),
			].filter(Boolean),
		});
	}

	if (schema?.type === 'Blog' || schemaTypes.includes('Blog')) {
		schemas.push({
			'@context': 'https://schema.org',
			'@type': 'Blog',
			name: SITE_NAME,
			description: SITE_DESCRIPTION,
			url: new URL('/blog/', Astro.site).toString(),
			publisher: {
				'@type': 'Organization',
				name: SITE_NAME,
			},
		});
	}

	// Add BreadcrumbList if provided
	if (schema?.breadcrumbs && schema.breadcrumbs.length > 0) {
		schemas.push({
			'@context': 'https://schema.org',
			'@type': 'BreadcrumbList',
			itemListElement: schema.breadcrumbs.map((crumb, index) => ({
				'@type': 'ListItem',
				position: index + 1,
				name: crumb.name,
				item: crumb.url,
			})),
		});
	}

	return schemas;
};

const schemas = buildSchema();
const fullTitle = title === SITE_TITLE ? title : `${title} | ${SITE_TITLE}`;
---

<!-- Primary Meta Tags -->
<title>{fullTitle}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />
{keywords && keywords.length > 0 && (
	<meta name="keywords" content={keywords.join(', ')} />
)}
<meta name="author" content={author.name} />
<meta name="robots" content={robots} />
<meta name="theme-color" content="#0ea5e9" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={pageURL} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:site_name" content={SITE_NAME} />
<meta property="og:locale" content={SITE_LOCALE} />
{imageURL && <meta property="og:image" content={imageURL.toString()} />}
{imageWidth && <meta property="og:image:width" content={imageWidth.toString()} />}
{imageHeight && <meta property="og:image:height" content={imageHeight.toString()} />}
{imageAlt && <meta property="og:image:alt" content={imageAlt} />}

{/* Article-specific OpenGraph tags */}
{article && type === 'article' && (
	<>
		{article.publishedTime && (
			<meta
				property="article:published_time"
				content={article.publishedTime.toISOString()}
			/>
		)}
		{article.modifiedTime && (
			<meta
				property="article:modified_time"
				content={article.modifiedTime.toISOString()}
			/>
		)}
		{article.author && (
			<meta property="article:author" content={article.author.name} />
		)}
		{article.section && <meta property="article:section" content={article.section} />}
		{article.tags &&
			article.tags.map((tag) => (
				<meta property="article:tag" content={tag} />
			))}
	</>
)}

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:url" content={pageURL.toString()} />
<meta name="twitter:title" content={title} />
<meta name="twitter:description" content={description} />
{imageURL && <meta name="twitter:image" content={imageURL.toString()} />}
{imageAlt && <meta name="twitter:image:alt" content={imageAlt} />}
{SITE_TWITTER_HANDLE && (
	<meta name="twitter:site" content={SITE_TWITTER_HANDLE} />
)}
{SITE_TWITTER_HANDLE && (
	<meta name="twitter:creator" content={SITE_TWITTER_HANDLE} />
)}

<!-- Canonical URL -->
<link rel="canonical" href={canonicalURL.toString()} />

<!-- Schema.org JSON-LD -->
{schemas.map((schema, index) => (
	<script
		type="application/ld+json"
		set:html={JSON.stringify(schema)}
		is:inline
	/>
))}
